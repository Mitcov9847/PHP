# Лабораторная работа №5. Работа с базой данных

## Цель работы

Изучить архитектуру с единой точкой входа, освоить подключение шаблонов для отображения страниц и перейти от хранения данных в файлах к использованию базы данных MySQL.

## Условия

Продолжить разработку проекта из предыдущей лабораторной работы, выполнив следующие задачи:

Реализовать архитектуру с единой точкой входа (index.php) для обработки всех HTTP-запросов.
Настроить систему шаблонов с использованием базового файла layout.php и отдельных шаблонов для страниц.
Перенести логику работы с рецептами из файлов в базу данных MySQL.

## Используемая среда

СУБД: MySQL (через phpMyAdmin, входящий в XAMPP)
Веб-сервер: Apache (в составе XAMPP)
Язык программирования: PHP 8.2
Интерфейс для работы с базой: phpMyAdmin (на localhost)
[!NOTE]
Примечание: phpMyAdmin по умолчанию работает с MariaDB, полностью совместимым с MySQL. В отчёте используется термин MySQL, как указано в задании.
![image](https://github.com/user-attachments/assets/af98e0ba-a287-41db-b240-3d52ba3fa658)


> [!NOTE]
> **Примечание**: хотя phpMyAdmin по умолчанию работает с сервером MariaDB, полностью совместимым с MySQL, в рамках отчёта мы будем использовать термин **MySQL**, как указано в задании.

## Настройка окружения через `XAMPP`

Для локальной разработки использовался XAMPP, включающий:

Apache — для работы PHP-приложения на локальном сервере.
MySQL — сервер баз данных, совместимый с MariaDB.
phpMyAdmin — интерфейс для управления базой данных.
В панели управления XAMPP были активированы модули Apache и MySQL. Приложение разрабатывалось по адресу http://localhost/recipe-book/public/index.php.

![image](https://github.com/user-attachments/assets/9ae169bc-06d7-4ace-b07a-0f0af2b2c071)

## Ход работы

### Задание 1. Подготовка среды

#### **Создана база данных `recipe_book` со следующими таблицами**

![image](https://i.imgur.com/qdRF79z.png)

#### Таблица `categories`

![image](https://i.imgur.com/aTfml50.png)

**Объяснение:**
Хранит категории рецептов (например, Завтрак, Ужин). Поле id — первичный ключ, created_at фиксирует время создания записи.

#### Таблица `recipes`

![image](https://i.imgur.com/dFyKRNC.png)

**Объяснение:**
Основная таблица для хранения рецептов. Содержит название, категорию (связь с categories), ингредиенты, описание, теги, шаги и дату создания. Внешний ключ category с ON DELETE CASCADE удаляет рецепты при удалении категории.

#### Таблица `steps`

![image](https://i.imgur.com/S5jh6xR.png)

**Объяснение:**
Хранит шаги приготовления для каждого рецепта. Поля: номер шага, описание и связь с рецептом через recipe_id.

#### Таблица `tags`

![image](https://i.imgur.com/V8UxqzK.png)

**Объяснение:**
Таблица с уникальными тегами (например, "веган", "быстро"). Используется в связке с `recipe_tag` для создания связи многие-ко-многим.

#### Таблица связи `recipe_tag`

![image](https://i.imgur.com/xJfLUu4.png)

**Объяснение:**
Промежуточная таблица для связи рецептов и тегов (многие-ко-многим). Составной ключ recipe_id, tag_id обеспечивает уникальность связей.

[!NOTE]
Таблицы steps, tags и recipe_tag созданы для поддержки шагов и тегов рецептов в рамках дополнительного задания.

> [!NOTE]
> **Таблицы `steps`, `tags` и `recipe_tag` реализованы в рамках дополнительного задания для поддержки шагов приготовления и тегов, связанных с рецептами.**

### Задание 2. Архитектура и шаблонизация

#### Структура проекта

```sh
recipe-book/
├── public/
│   └── index.php                 # Главная страница (отображение всех рецептов)
├── src/
│   ├── handlers/
│   │   ├── recipe/
│   │   │   ├── create.php        # Логика обработки создания рецепта
│   │   │   ├── edit.php          # Логика редактирования рецепта
│   │   │   ├── show.php          # Логика  для отображения рецепта.
│   │   │   └── delete.php        # Логика удаления рецепта
│   ├── db.php                    # Файл для подключения к базе данных             # Дополнительные функции (если нужны)
├── config/
│   └── db.php                    # Параметры подключения к базе данных (например, настройки для PDO)
├── templates/
│   ├── layout.php                # Основной шаблон для страниц (содержит общую разметку и подключение контента)
│   ├── index.php                 # Шаблон для главной страницы (отображение всех рецептов)
│   └── recipe/
│       ├── create.php            # Шаблон для формы добавления рецепта
│       ├── delete.php            # Шаблон для формы удаления рецепта
│       ├── edit.php              # Шаблон для формы редактирования рецепта
│       └── show.php              # Шаблон для страницы с подробной информацией о рецепте

```

**`public/index.php`**

```php
<?php

/**
 * Обработка параметра 'page' из URL и загрузка соответствующей страницы.
 * Если параметр 'page' не передан, то по умолчанию загружается главная страница.
 * В зависимости от значения параметра 'page', загружаются разные обработчики для рецептов.
 * 
 * @var string $page Название страницы, которая будет загружена.
 * Может быть 'index', 'create', 'show', 'edit' или 'delete'.
 */

$page = $_GET['page'] ?? 'index'; // По умолчанию страница - главная

switch ($page) {
    /**
     * Обрабатывает запрос на создание нового рецепта.
     * Подключает файл обработчика для создания рецепта.
     */
    case 'create':
        require_once __DIR__ . '/../src/handlers/recipe/create.php';
        break;
    
    /**
     * Обрабатывает запрос на отображение рецепта.
     * Подключает файл обработчика для отображения рецепта.
     */
    case 'show':
        require_once __DIR__ . '/../src/handlers/recipe/show.php'; // Показывать рецепт
        break;

    /**
     * Обрабатывает запрос на редактирование рецепта.
     * Подключает файл обработчика для редактирования рецепта.
     */
    case 'edit':
        require_once __DIR__ . '/../src/handlers/recipe/edit.php';
        break;

    /**
     * Обрабатывает запрос на удаление рецепта.
     * Подключает файл обработчика для удаления рецепта.
     */
    case 'delete':
        require_once __DIR__ . '/../src/handlers/recipe/delete.php';
        break;

    /**
     * Загружает главную страницу приложения.
     * Если параметр 'page' не совпадает с любым из известных значений, загружается главная страница.
     */
    default:
        require_once __DIR__ . '/../templates/index.php'; // Главная страница с рецептом
}
```

- Файл index.php — единая точка входа веб-приложения, выполняющая маршрутизацию на основе GET-параметра page.

Функциональность
Получение параметра page:
Берет $_GET['page'] или устанавливает 'index' по умолчанию.
Маршрутизация:
Через switch подключает файлы:
create: src/handlers/recipe/create.php — создание рецепта.
show: src/handlers/recipe/show.php — просмотр рецепта.
edit: src/handlers/recipe/edit.php — редактирование рецепта.
delete: src/handlers/recipe/delete.php — удаление рецепта.
default: templates/index.php — главная страница.
Модульность:
Использует require_once, разделяя логику и представление.

**`templates/layout.php`**

```<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <!-- Заголовок страницы, если переменная $title не установлена, используется "Recipe Book" -->
    <title><?= $title ?? 'Recipe Book' ?></title>
</head>
<body>
    <header>
        <h1>Проект Recipe Book</h1>
        <nav>
            <!-- Ссылка на главную страницу -->
            <a href="/recipe-book/public/?page=index">Главная</a>
        </nav>
        <hr>
    </header>

    <main>
        <!-- Контент страницы. Если переменная $content не установлена, то выводится пустая строка -->
        <?= $content ?? '' ?>
    </main>

    <footer>
        <hr>
        <!-- Футер с текущим годом -->
        <p>&copy; <?= date('Y') ?> USM book</p>
    </footer>
</body>
</html>

```

- Это основной шаблон для страниц проекта, который включает в себя общую структуру сайта и вставляет динамический контент.

- **Шапка (`header`)**:
  - Заголовок страницы: `Проект Recipe Book`.
  - Ссылка на главную страницу.

- **Основной контент (`main`)**:
  - Выводит динамический контент, переданный через переменную `$content`.

- **Подвал (`footer`)**:
  - Текущий год и права: `&copy; 2025 USM book`.

**`templates/index.php (фрагмент)`**

```php
/**
 * Шаблон вывода всех рецептов с пагинацией.
 *
 * @var array $recipes Массив рецептов
 * @global int $page Текущая страница
 * @global int $totalPages Общее количество страниц
 */

<?php foreach ($recipes as $recipe): ?>
    <li>
        <strong><?= htmlspecialchars($recipe['title']) ?></strong><br>
        Категория: <?= htmlspecialchars($recipe['category_name']) ?><br>
        Добавлен: <?= $recipe['created_at'] ?><br>

        <div class="actions">
            <a class="details-button" href="/public/recipe/show.php?id=<?= $recipe['id'] ?>">Подробнее</a>

            <form method="POST" action="/public/recipe/delete.php" class="inline-form" onsubmit="return confirm('Удалить рецепт?');">
                <input type="hidden" name="id" value="<?= $recipe['id'] ?>">
                <button class="delete-button" type="submit">Удалить</button>
            </form>
        </div>
    </li>
<?php endforeach; ?>
```

- Этот шаблон выводит список всех рецептов, полученных из базы данных. Каждая запись выводится в виде карточки с заголовком, категорией и датой добавления. Для каждого рецепта реализованы две основные функции:

  - Кнопка "Подробнее" открывает страницу `show.php`, где отображаются все детали рецепта;

  - Кнопка "Удалить" реализована как HTML-форма с методом `POST`, что соответствует REST-принципам безопасности. Кнопка дополнительно защищена `confirm()` - проверкой, чтобы избежать случайного удаления.

Кроме того, все поля проходят обработку через `htmlspecialchars()` для защиты от XSS-атак. Этот шаблон — часть MVC-архитектуры и отвечает за представление (View).

**`templates/recipe/create.php (фрагмент)`**

```<?php
$title = 'Добавить рецепт'; // Устанавливаем заголовок страницы

ob_start(); // Начинаем буферизацию вывода

?>

<h2>Добавить рецепт</h2>

<form action="/recipe-book/public/?page=create" method="post">
    <!-- Форма для добавления рецепта -->
    
    <div>
        <label for="title">Название рецепта:</label><br>
        <!-- Поле для ввода названия рецепта -->
        <input type="text" id="title" name="title" required>
    </div>

    <div>
        <label for="category">Категория:</label><br>
        <!-- Выпадающий список для выбора категории -->
        <select id="category" name="category" required>
            <option value="">-- Выберите категорию --</option>
            <?php foreach ($categories as $cat): ?>
                <!-- Перебираем категории и выводим их в список -->
                <option value="<?= htmlspecialchars($cat['id']) ?>">
                    <?= htmlspecialchars($cat['name']) ?>
                </option>
            <?php endforeach; ?>
        </select>
    </div>

    <div>
        <label for="ingredients">Ингредиенты:</label><br>
        <!-- Текстовое поле для ввода ингредиентов -->
        <textarea id="ingredients" name="ingredients" rows="4"></textarea>
    </div>

    <div>
        <label for="description">Описание:</label><br>
        <!-- Текстовое поле для описания рецепта -->
        <textarea id="description" name="description" rows="4"></textarea>
    </div>

    <div>
        <label for="tags">Теги (через запятую):</label><br>
        <!-- Поле для ввода тегов -->
        <input type="text" id="tags" name="tags">
    </div>

    <div>
        <label for="steps">Шаги приготовления:</label><br>
        <!-- Текстовое поле для описания шагов приготовления -->
        <textarea id="steps" name="steps" rows="6"></textarea>
    </div>

    <br>
    <button type="submit">Сохранить</button> <!-- Кнопка для отправки формы -->
</form>

<?php
$content = ob_get_clean(); // Завершаем буферизацию вывода и сохраняем содержимое
require __DIR__ . '/../layout.php'; // Подключаем общий шаблон для страницы

```
- Этот файл представляет форму для добавления нового рецепта.

#### Основные элементы:

1. **Заголовок страницы**:
   - Устанавливается заголовок страницы: "Добавить рецепт".

2. **Форма для добавления рецепта**:
   - **Название рецепта** — поле для ввода.
   - **Категория** — выпадающий список с категориями, загружаемыми из базы данных.
   - **Ингредиенты, описание, теги, шаги** — текстовые поля для ввода соответствующих данных.

3. **Кнопка "Сохранить"**:
   - Отправляет форму на сервер методом POST.

4. **Буферизация вывода**:
   - Код HTML сохраняется в буфере с помощью `ob_start()`, а затем передается в общий шаблон `layout.php`.

#### Важные моменты:
- При отправке формы данные передаются на страницу `create` для обработки.
- Динамическая загрузка категорий рецептов из базы данных с помощью PHP.

**`templates/recipe/show.php`**

```<?php
$title = 'Рецепт: ' . htmlspecialchars($recipe['title']); // Заголовок страницы, включающий название рецепта

ob_start(); // Начинаем буферизацию вывода
?>

<h2>Рецепт: <?= htmlspecialchars($recipe['title']) ?></h2>
<!-- Заголовок с названием рецепта -->

<p><strong>Категория:</strong> <?= htmlspecialchars($recipe['category_name']) ?></p>
<!-- Отображаем категорию рецепта -->

<p><strong>Ингредиенты:</strong></p>
<p><?= nl2br(htmlspecialchars($recipe['ingredients'])) ?></p>
<!-- Отображаем ингредиенты рецепта. Функция nl2br преобразует новые строки в <br> для корректного отображения -->

<p><strong>Описание:</strong></p>
<p><?= nl2br(htmlspecialchars($recipe['description'])) ?></p>
<!-- Отображаем описание рецепта с переносами строк -->

<p><strong>Теги:</strong> <?= htmlspecialchars($recipe['tags']) ?></p>
<!-- Отображаем теги рецепта -->

<p><strong>Шаги приготовления:</strong></p>
<p><?= nl2br(htmlspecialchars($recipe['steps'])) ?></p>
<!-- Отображаем шаги приготовления рецепта с преобразованием новых строк в <br> -->

<a href="/recipe-book/public/?page=index">Назад к списку рецептов</a>
<!-- Ссылка на главную страницу с перечнем рецептов -->

<?php
$content = ob_get_clean(); // Завершаем буферизацию вывода и сохраняем содержимое
require __DIR__ . '/../layout.php'; // Подключаем общий шаблон для страницы

```

- Этот файл отображает подробную информацию о конкретном рецепте.

#### Основные элементы:

1. **Заголовок страницы**:
   - Формируется заголовок с названием рецепта: "Рецепт: {название рецепта}".

2. **Детали рецепта**:
   - **Название рецепта** — отображается в заголовке.
   - **Категория** — отображается категория рецепта.
   - **Ингредиенты** — отображаются ингредиенты, с учетом переноса строк (используется `nl2br()`).
   - **Описание** — отображается описание рецепта, с учетом переноса строк.
   - **Теги** — отображаются теги рецепта.
   - **Шаги приготовления** — отображаются шаги приготовления, с учетом переноса строк.

3. **Ссылка "Назад"**:
   - Ссылка для возвращения на главную страницу с перечнем рецептов.

4. **Буферизация вывода**:
   - Код HTML сохраняется в буфере с помощью `ob_start()`, а затем передается в общий шаблон `layout.php`.

#### Важные моменты:
- Использование `htmlspecialchars()` для предотвращения XSS-атак.
- `nl2br()` используется для правильного отображения переноса строк в описаниях и шагах.


### Задание 3. Подключение к базе данных

**`src/db.php`**

```php
<?php
/**
 * Функция для получения объекта PDO, который используется для работы с базой данных.
 *
 * @return PDO
 */
function getPDO(): PDO
{
    // Загружаем конфигурацию из файла
    $config = require __DIR__ . '/../config/db.php';

    // Формируем DSN для подключения к MySQL
    $dsn = "mysql:host={$config['host']};dbname={$config['dbname']};charset=utf8mb4";

    try {
        // Пытаемся подключиться к базе данных с использованием PDO
        $pdo = new PDO($dsn, $config['user'], $config['password'], [
            PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION, // Включаем обработку ошибок
        ]);
        return $pdo;
    } catch (PDOException $e) {
        // Если ошибка подключения — выводим сообщение
        die("Ошибка подключения к БД: " . $e->getMessage());
    }
}

```
### Функция `getPDO()`

Эта функция отвечает за создание и возврат объекта **PDO** для подключения к базе данных MySQL.

#### Основные шаги:

1. **Загрузка конфигурации**:
   - Загружается конфигурационный файл из директории `config/db.php`, который содержит параметры подключения к базе данных, такие как `host`, `dbname`, `user` и `password`.

2. **Формирование DSN**:
   - Используется строка DSN (Data Source Name), которая включает в себя хост, имя базы данных и кодировку (UTF-8). Это строка, необходимая для подключения к базе данных.

3. **Создание подключения**:
   - Создается объект PDO с использованием DSN и данных для подключения (пользователь и пароль).
   - Включается режим обработки ошибок через `PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION`, что позволяет перехватывать исключения в случае ошибок подключения.

4. **Обработка ошибок**:
   - В случае ошибки подключения с помощью `try-catch` блоков, функция выведет сообщение об ошибке и прекратит выполнение программы с помощью `die()`.

#### Пример использования:
Функция `getPDO()` возвращает объект PDO, который можно использовать для выполнения SQL-запросов к базе данных.


**Файл `config/db.php` — содержит параметры подключения**

```<?php
return [
    'host' => 'localhost',      // Твой сервер базы данных
    'dbname' => 'recipe_book',   // Имя базы данных
    'user' => 'root',            // Имя пользователя БД
    'password' => '',           
];

```
- Это конфигурационный файл, который позволяет удобно менять параметры БД в одном месте. Он подключается в `db.php` и не содержит логики.

### Задание 3. Реализация CRUD-функциональности

**`src/handlers/recipe/create.php`**

```<?php
require_once __DIR__ . '/../../db.php';

/**
 * Получение экземпляра PDO для работы с базой данных.
 */
$pdo = getPDO();

/**
 * Проверка, был ли отправлен POST-запрос.
 * Если да — выполняем добавление рецепта в базу данных.
 */
if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    // Извлекаем данные из формы. Если данные не переданы, то устанавливаем дефолтное значение.
    $title = $_POST['title'] ?? ''; 
    $category = (int) ($_POST['category'] ?? 0); // Преобразуем категорию в целое число
    $ingredients = $_POST['ingredients'] ?? ''; 
    $description = $_POST['description'] ?? ''; 
    $tags = $_POST['tags'] ?? ''; 
    $steps = $_POST['steps'] ?? ''; 

    /**
     * Простейшая валидация формы:
     * Проверяем обязательные поля: название и категория.
     * Если они не заполнены, выводим сообщение об ошибке.
     */
    if (empty($title) || $category === 0) {
        die('Название и категория обязательны.');
    }

    /**
     * Подготавливаем SQL-запрос для вставки данных о рецепте в базу данных.
     * Используем подготовленные выражения для защиты от SQL-инъекций.
     */
    $stmt = $pdo->prepare('INSERT INTO recipes (title, category, ingredients, description, tags, steps) 
                            VALUES (:title, :category, :ingredients, :description, :tags, :steps)');

    // Выполняем запрос с данными, переданными из формы.
    $stmt->execute([
        'title' => $title,
        'category' => $category,
        'ingredients' => $ingredients,
        'description' => $description,
        'tags' => $tags,
        'steps' => $steps,
    ]);

    /**
     * После успешного добавления рецепта, перенаправляем пользователя на главную страницу.
     */
    header('Location: /recipe-book/public/');
    exit;
}

/**
 * Если форма НЕ была отправлена, готовим данные для отображения на странице создания рецепта.
 * Загружаем все категории для выпадающего списка.
 */
$stmt = $pdo->query('SELECT * FROM categories ORDER BY name');
$categories = $stmt->fetchAll(PDO::FETCH_ASSOC);

/**
 * Подключаем шаблон для отображения формы добавления рецепта.
 */
require_once __DIR__ . '/../../../templates/recipe/create.php';

```

- Обработчик формы добавления рецепта. 
Этот код представляет собой обработчик для страницы добавления нового рецепта. Вот что он делает:

### Основные шаги:

1. **Подключение к базе данных**:
   - В начале загружается файл с функцией для подключения к базе данных `require_once __DIR__ . '/../../db.php';`.
   - Получаем объект PDO для работы с базой данных с помощью функции `getPDO()`.

2. **Обработка POST-запроса**:
   - Проверяется, был ли отправлен POST-запрос. Это происходит с помощью условия `if ($_SERVER['REQUEST_METHOD'] === 'POST')`.
   - Если запрос был отправлен, извлекаются данные из формы:
     - **title**, **category**, **ingredients**, **description**, **tags**, **steps** — все эти данные могут быть переданы через POST-запрос.
     - Если данные не переданы, устанавливаются значения по умолчанию.

3. **Валидация данных**:
   - Проверяется, что обязательные поля (**title** и **category**) заполнены. Если одно из них пусто, выводится ошибка: `'Название и категория обязательны.'`.

4. **Подготовка и выполнение SQL-запроса**:
   - С помощью подготовленного выражения `INSERT INTO` вставляем данные о рецепте в таблицу `recipes` базы данных.
   - Используется метод `prepare` для защиты от SQL-инъекций.

5. **Перенаправление**:
   - После успешного добавления рецепта, происходит перенаправление на главную страницу проекта (`/recipe-book/public/`), используя `header('Location: /recipe-book/public/');`.

6. **Если форма не была отправлена**:
   - Если форма не была отправлена (т.е. страница загружена впервые), выполняется запрос для получения всех категорий рецептов из базы данных.
   - Эти категории затем будут отображаться в выпадающем списке на форме.

7. **Отображение формы**:
   - Подключается шаблон `create.php` для отображения формы добавления рецепта, где будет доступен выпадающий список с категориями.

### Примечания:
- Это типичный обработчик формы для добавления данных в базу.
- Валидация проста и ограничивается только проверкой обязательных полей.
- Для защиты от SQL-инъекций используется подготовленное выражение с параметризованными запросами.

### Потенциальные улучшения:
- Могут быть добавлены дополнительные проверки и валидация данных (например, для полей **ingredients**, **steps** и **tags**).
- Можно реализовать проверку ошибок при вставке данных (например, что делать, если запрос не удался).


**`src/handlers/recipe/delete.php`**

``<?php
require_once __DIR__ . '/../../db.php';

/**
 * Получаем PDO для работы с базой данных.
 */
$pdo = getPDO();

/**
 * Проверяем наличие ID в GET-параметре.
 */
if (isset($_GET['id'])) {
    $id = (int) $_GET['id']; // Преобразуем ID в число

    /**
     * Проверяем, существует ли рецепт с таким ID.
     */
    $stmt = $pdo->prepare('SELECT * FROM recipes WHERE id = :id');
    $stmt->execute(['id' => $id]);
    $recipe = $stmt->fetch(PDO::FETCH_ASSOC);

    if ($recipe) {
        /**
         * Удаляем рецепт с данным ID.
         */
        $stmt = $pdo->prepare('DELETE FROM recipes WHERE id = :id');
        $stmt->execute(['id' => $id]);

        /**
         * Перенаправляем, если удаление прошло успешно.
         */
        if ($stmt->rowCount() > 0) {
            header('Location: /recipe-book/public/?page=index');
            exit;
        } else {
            die('Ошибка удаления рецепта.');
        }
    } else {
        die('Рецепт не найден.');
    }
} else {
    die('ID рецепта не указан.');
}

```
- ### Краткое описание кода:

1. **Подключение к базе данных**:
   - Загружается файл с функцией для подключения к базе данных `require_once __DIR__ . '/../../db.php';`.

2. **Проверка GET-параметра `id`**:
   - Если параметр `id` существует в URL, он преобразуется в целое число.

3. **Проверка наличия рецепта с данным `id`**:
   - Выполняется запрос в базу данных для поиска рецепта с указанным ID.

4. **Удаление рецепта**:
   - Если рецепт найден, выполняется запрос на его удаление.

5. **Перенаправление после успешного удаления**:
   - Если рецепт успешно удалён, происходит перенаправление на страницу списка рецептов.

6. **Обработка ошибок**:
   - В случае ошибок (например, если рецепт не найден или ID не указан), выводится соответствующее сообщение.

### Потенциальные улучшения:
- Добавить подтверждение перед удалением.
- Добавить обработку ошибок при подключении к базе данных.
```

**`templates/recipe/edit.php**

```<?php
require_once __DIR__ . '/../../db.php';

/**
 * Получаем PDO для работы с базой данных.
 */
$pdo = getPDO();

/**
 * Проверяем наличие ID в GET-параметре.
 */
if (isset($_GET['id'])) {
    $id = (int) $_GET['id']; // Преобразуем ID в число

    /**
     * Получаем данные рецепта по ID.
     */
    $stmt = $pdo->prepare('SELECT * FROM recipes WHERE id = :id');
    $stmt->execute(['id' => $id]);
    $recipe = $stmt->fetch(PDO::FETCH_ASSOC);

    // Если рецепт найден
    if ($recipe) {
        /**
         * Если форма отправлена методом POST, обновляем рецепт.
         */
        if ($_SERVER['REQUEST_METHOD'] === 'POST') {
            $title = $_POST['title'] ?? '';
            $category = (int) ($_POST['category'] ?? 0);
            $ingredients = $_POST['ingredients'] ?? '';
            $description = $_POST['description'] ?? '';
            $tags = $_POST['tags'] ?? '';
            $steps = $_POST['steps'] ?? '';

            // Валидация обязательных полей
            if (empty($title) || $category === 0) {
                die('Название и категория обязательны.');
            }

            /**
             * Обновляем рецепт в базе данных.
             */
            $stmt = $pdo->prepare('UPDATE recipes SET title = :title, category = :category, ingredients = :ingredients, description = :description, tags = :tags, steps = :steps WHERE id = :id');
            $stmt->execute([
                'title' => $title,
                'category' => $category,
                'ingredients' => $ingredients,
                'description' => $description,
                'tags' => $tags,
                'steps' => $steps,
                'id' => $id
            ]);

            /**
             * Перенаправляем на страницу с обновленным рецептом.
             */
            header('Location: /recipe-book/public/?page=show&id=' . $id);
            exit;
        }

        /**
         * Получаем список категорий для формы.
         */
        $stmt = $pdo->query('SELECT * FROM categories ORDER BY name');
        $categories = $stmt->fetchAll(PDO::FETCH_ASSOC);

        /**
         * Подключаем шаблон редактирования рецепта.
         */
        require_once __DIR__ . '/../../../templates/recipe/edit.php';
    } else {
        die('Рецепт не найден.');
    }
} else {
    die('ID рецепта не указан.');
}

```
- 1. **Подключение к базе данных**:
   - Загружается файл с функцией для подключения к базе данных `require_once __DIR__ . '/../../db.php';`.

2. **Проверка GET-параметра `id`**:
   - Если параметр `id` существует в URL, он преобразуется в целое число.

3. **Получение данных рецепта по ID**:
   - Выполняется запрос для получения рецепта с указанным `id` из базы данных.

4. **Обработка POST-запроса**:
   - Если форма отправлена методом POST, происходит валидация данных и обновление рецепта в базе данных.

5. **Обновление данных рецепта**:
   - Если все обязательные поля заполнены, данные рецепта обновляются в базе данных.

6. **Перенаправление**:
   - После успешного обновления, происходит перенаправление на страницу рецепта с новым ID.

7. **Получение списка категорий**:
   - Загружаются все категории для выбора в форме редактирования.

8. **Подключение шаблона редактирования**:
   - Подключается шаблон для отображения формы редактирования рецепта.

**`src/handlers/recipe/show.php`**

```
<?php
require_once __DIR__ . '/../../db.php';

/** Получаем PDO для работы с базой данных.
 */
$pdo = getPDO();

/** Получаем ID рецепта из URL (GET параметра).
 */
$recipeId = $_GET['id'] ?? null;

if ($recipeId) {
    /*Запрос для получения рецепта по ID, с добавлением имени категории. */
    $stmt = $pdo->prepare('SELECT r.*, c.name AS category_name FROM recipes r 
                           JOIN categories c ON r.category = c.id WHERE r.id = :id');
    $stmt->execute(['id' => $recipeId]);
    $recipe = $stmt->fetch(PDO::FETCH_ASSOC);

    // Если рецепт не найден
    if (!$recipe) {
        die('Рецепт не найден.');
    }
} else {
    die('ID рецепта не задан.');
}

/* Подключаем шаблон для отображения рецепта.*/
require_once __DIR__ . '/../../../templates/recipe/show.php';

```
1. **Подключение к базе данных**:
   - Загружается файл с функцией для подключения к базе данных: `require_once __DIR__ . '/../../db.php';`.

2. **Получение ID рецепта из URL**:
   - Из URL извлекается параметр `id` для запроса рецепта.

3. **Запрос на получение рецепта по ID**:
   - Выполняется SQL-запрос с `JOIN` для получения рецепта по ID, включая название категории.
   - Если рецепт с данным ID не найден, выводится сообщение об ошибке.

4. **Проверка наличия рецепта**:
   - Если рецепт найден, переход к следующему шагу; если нет — выводится ошибка: "Рецепт не найден".

5. **Подключение шаблона для отображения рецепта**:
   - Если рецепт найден, подключается шаблон `show.php` для отображения его данных.

### Задание 4. Защита от SQL-инъекций

#### Используемая защита в проекте

**Все SQL-запросы выполняются через подготовленные выражения (prepared statements):**

***Пример: добавление рецепта***

```php
$stmt = $pdo->prepare("INSERT INTO recipes (title, category, ingredients, description) VALUES (?, ?, ?, ?)");
$stmt->execute([$title, $category, $ingredients, $description]);
```

***Пример: выборка по ID***

```php
$stmt = $pdo->prepare("SELECT * FROM recipes WHERE id = ?");
$stmt->execute([$id]);
```

***Пример: удаление по ID***

```php
$stmt = $pdo->prepare("DELETE FROM recipes WHERE id = ?");
$stmt->execute([$id]);
```

- Подготовленные выражения в PDO работают так, что структура SQL-запроса передаётся отдельно от пользовательских данных. Это предотвращает внедрение вредоносного кода, потому что данные интерпретируются строго как значения, а не как часть SQL-команды.

#### Валидация и фильтрация данных

Все входные значения:

- очищаются с помощью `trim()` для удаления лишних пробелов;

- преобразуются в `int` при необходимости (например, ID и category);

- текстовые поля экранируются при выводе с помощью `htmlspecialchars()` для защиты от XSS.

#### Пример SQL-инъекции без защиты

Если бы код выглядел так:

```php
// Плохо: данные напрямую подставляются в запрос
$id = $_GET['id'];
$result = $pdo->query("SELECT * FROM recipes WHERE id = $id");
```

Пользователь может ввести:

```bash
?id=1 OR 1=1
```

Результат: SQL-запрос превращается в:

```sql
SELECT * FROM recipes WHERE id = 1 OR 1=1
```

- Это приведёт к выводу всех рецептов, независимо от их ID, и потенциально — к раскрытию конфиденциальных данных.

#### Как мы это предотвращаем

```php
$id = (int)$_GET['id'];
$stmt = $pdo->prepare("SELECT * FROM recipes WHERE id = ?");
$stmt->execute([$id]);
```

Даже если пользователь передаст `1 OR 1=1`, всё будет трактоваться как строка, а не SQL-команда.
PDO автоматически экранирует значения, и SQL-инъекция становится невозможной.


## Результат

Главная страница

![image](https://github.com/user-attachments/assets/97093700-46cf-4203-9a17-afabd4313272)

Добавление рецепта

![image](https://github.com/user-attachments/assets/e487f34c-e423-4bd6-b0f6-23b50c48c22e)

![image](https://github.com/user-attachments/assets/f330b7d2-d2a7-41a6-8174-ffd85e4c3ea1)

Все рецепты
![image](https://github.com/user-attachments/assets/da2199b0-dc73-423a-8bed-dcac1ab79b3f)

Кнопки редактирования и удаления рецепта
![image](https://github.com/user-attachments/assets/2a0da971-c1fe-449a-bf7f-9e84eac0ff0e)

Форма редактирования рецепта
![image](https://github.com/user-attachments/assets/37cb3e80-0d9e-4391-b6c2-5472952b804c)

## Контрольные вопросы
Какие преимущества даёт использование единой точки входа в веб-приложении?
Использование единой точки входа (например, index.php) помогает централизовать обработку всех входящих запросов, упрощая маршрутизацию и организацию логики приложения. Это облегчает управление контроллерами и шаблонами, а также повышает масштабируемость приложения.

Какие преимущества даёт использование шаблонов?
Шаблоны помогают разделить логику обработки данных и представление. Это улучшает читаемость и поддержку кода, а также позволяет повторно использовать части интерфейса на разных страницах приложения. Система шаблонов упрощает работу с HTML и делает приложение более гибким.

Какие преимущества даёт хранение данных в базе по сравнению с хранением в файлах?
Хранение данных в базе данных позволяет легко управлять большими объемами информации, осуществлять сложные запросы, поддерживать целостность данных и гарантировать быстрый доступ. В отличие от файлов, базы данных поддерживают индексацию, поиск, и могут обеспечить большую степень безопасности и масштабируемости.

Что такое SQL-инъекция? Придумайте пример SQL-инъекций и объясните, как её предотвратить.
SQL-инъекция — это метод атаки на веб-приложение, при котором злоумышленник вставляет или "внедряет" вредоносный SQL-код в запросы к базе данных. Пример инъекции: если поле для ввода имени пользователя в форме не защищено, можно ввести что-то вроде admin' OR 1=1 --, что приведет к выполнению запроса, который вернет все данные из таблицы. Чтобы предотвратить SQL-инъекции, необходимо использовать подготовленные выражения (prepared statements) и тщательно проверять и фильтровать входные данные.

## Заключение
Проект "Recipe Book" представляет собой функциональное веб-приложение для управления рецептами, в котором реализованы все основные функции CRUD, защита от SQL-инъекций, пагинация и шаблонная система. Все данные хранятся в базе данных, что значительно упрощает управление ими по сравнению с использованием файловой системы. Приложение имеет хорошо организованную архитектуру с единой точкой входа и использует передовые практики разработки, такие как подготовленные выражения, инкапсуляция работы с базой данных и использование шаблонов для представления данных.

## Библиография

1. [PHP Manual](https://www.php.net/manual/ru/)
2. [Описание XAMPP](https://www.apachefriends.org/ru/index.html)
3. [Документация по SQL и MySQL](https://dev.mysql.com/doc/)
